Index: core/matching.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import numpy as np\r\nfrom typing import List, Dict\r\nfrom sqlalchemy.orm import Session\r\nfrom core.database import SessionLocal\r\nfrom candidates_models import Candidate\r\nfrom core.job_description_model import JobDescription\r\nfrom candidates_models import CandidateJobScore, CandidateIndustryCache  # Az új adatbázis táblák importálása\r\nfrom INDUSTRY_KEYWORDS import INDUSTRY_KEYWORDS\r\nfrom cache_logic import get_cached_vector, preprocess_and_cache\r\nfrom concurrent.futures import ThreadPoolExecutor\r\nimport openai\r\nimport os\r\n# Constants for weightage\r\nINDUSTRY_KNOWLEDGE_WEIGHT = 0.10\r\nTECHNICAL_SKILLS_WEIGHT = 0.30\r\nJOB_MATCHING_WEIGHT = 0.60\r\nopenai.api_key = os.getenv(\"OPENAI_API_KEY\")\r\n\r\n\r\ndef match_industry_keywords(text: str, db: Session) -> List[str]:\r\n    matched_industries = []\r\n    cleaned_text = text.lower().strip()\r\n\r\n    if not cleaned_text:\r\n        return matched_industries\r\n\r\n    # Szöveg vektor lekérése cache-ből vagy vektorizáció\r\n    text_vector = get_cached_vector(cleaned_text)\r\n\r\n    if np.linalg.norm(text_vector) == 0:\r\n        print(\"The provided text does not have valid vectors.\")\r\n        return matched_industries\r\n\r\n    for industry, keywords in INDUSTRY_KEYWORDS.items():\r\n        similarity_scores = []\r\n\r\n        for keyword in keywords:\r\n            keyword_clean = keyword.lower().strip()\r\n            # Kulcsszó vektor lekérése\r\n            keyword_vector = get_cached_vector(keyword_clean)\r\n\r\n            if np.linalg.norm(keyword_vector) > 0:\r\n                # Koszinusz hasonlóság számítása\r\n                similarity = np.dot(text_vector, keyword_vector) / (np.linalg.norm(text_vector) * np.linalg.norm(keyword_vector))\r\n                similarity_scores.append(similarity)\r\n\r\n        if similarity_scores:\r\n            # Átlagos hasonlóság egy iparág számára\r\n            average_similarity = sum(similarity_scores) / len(similarity_scores)\r\n\r\n            # Szigorúbb küszöbérték\r\n            if average_similarity > 0.45:\r\n                matched_industries.append(industry)\r\n\r\n    return matched_industries\r\n\r\n# Iparági Pontszám Számítása Cache Használatával\r\ndef calculate_industry_score_cached(candidate: Candidate, job_description: JobDescription, db: Session) -> float:\r\n    candidate_industries = db.query(CandidateIndustryCache).filter_by(candidate_id=candidate.id).all()\r\n    job_industries = [industry.industry_name for industry in job_description.industries if industry.industry_name]\r\n\r\n    if not candidate_industries or not job_industries:\r\n        print(f\"No industry data available for comparison.\")\r\n        return 0.0\r\n\r\n    matching_fields = set([ci.industry_name for ci in candidate_industries]).intersection(set(job_industries))\r\n    total_fields = len(job_industries)\r\n\r\n    match_percentage = (len(matching_fields) / total_fields) * 100\r\n    #print(f\"Matching Fields (Cached): {matching_fields}\")\r\n    #print(f\"Match Percentage (Cached): {match_percentage}%\")\r\n\r\n    return match_percentage\r\n\r\n# Technikai Skillek Pontszám Számítása Cache Használatával\r\ndef calculate_technical_skills_score_cached(candidate: Candidate, job_description: JobDescription,\r\n                                            threshold: float = 0.6, db: Session = None) -> float:\r\n\r\n    required_skills = [skill.skill_name.lower() for skill in job_description.skills if skill.skill_name]\r\n    candidate_skills = [skill.skill_name.lower() for skill in candidate.skills if skill.skill_name]\r\n\r\n    if not required_skills:\r\n        print(\"No skills required in the job description.\")\r\n        return 0.0\r\n\r\n    if not candidate_skills:\r\n        print(f\"No skills found for Candidate: {candidate.first_name} {candidate.last_name}\")\r\n        return 0.0\r\n\r\n    total_score = 0\r\n\r\n    for req_skill in required_skills:\r\n        req_vector = get_cached_vector(req_skill)\r\n        if np.linalg.norm(req_vector) == 0:\r\n            continue\r\n        max_similarity = 0\r\n        for cand_skill in candidate_skills:\r\n            cand_vector = get_cached_vector(cand_skill)\r\n            if np.linalg.norm(cand_vector) == 0:\r\n                continue\r\n            similarity = np.dot(req_vector, cand_vector) / (np.linalg.norm(req_vector) * np.linalg.norm(cand_vector))\r\n            if similarity > max_similarity:\r\n                max_similarity = similarity\r\n\r\n        if max_similarity >= threshold:\r\n            total_score += max_similarity\r\n\r\n    technical_score = (total_score / len(required_skills)) * 100 if required_skills else 0.0\r\n    #print(f\"Technical Skills Score (Cached): {technical_score}\")\r\n\r\n    return technical_score\r\n# Job Description Matching Score számítása\r\ndef calculate_job_matching_score(candidate: Candidate, job_description: JobDescription, db: Session) -> float:\r\n    candidate_experience_text = \" \".join([exp.description.lower() for exp in candidate.experiences if exp.description]).strip()\r\n    job_requirements_text = \" \".join([resp.description.lower() for resp in job_description.responsibilities if resp.description]).strip()\r\n\r\n    if not candidate_experience_text:\r\n        print(\"No candidate experience data available.\")\r\n        return 0.0\r\n\r\n    if not job_requirements_text:\r\n        print(\"No job requirements data available.\")\r\n        return 0.0\r\n\r\n    # Szöveg vektorok lekérése\r\n    candidate_vector = get_cached_vector(candidate_experience_text)\r\n    job_vector = get_cached_vector(job_requirements_text)\r\n\r\n    if np.linalg.norm(candidate_vector) == 0 or np.linalg.norm(job_vector) == 0:\r\n        print(\"No valid vectors for similarity calculation.\")\r\n        return 0.0\r\n\r\n    # Koszinusz hasonlóság számítása\r\n    similarity = np.dot(candidate_vector, job_vector) / (np.linalg.norm(candidate_vector) * np.linalg.norm(job_vector))\r\n    job_matching_score = similarity * 100\r\n    #print(f\"Job Matching Score: {job_matching_score}\")\r\n    return job_matching_score\r\n\r\n# Pontszámok kiszámítása és mentése\r\ndef calculate_and_save_final_score(candidate: Candidate, job_description: JobDescription, db: Session):\r\n    # Pontszámítás\r\n    try:\r\n        industry_score = float(calculate_industry_score_cached(candidate, job_description, db))\r\n        print(f\"Industry Score for Candidate {candidate.first_name} {candidate.last_name}: {industry_score}\")\r\n\r\n        technical_score = float(calculate_technical_skills_score_cached(candidate, job_description, db=db))\r\n        print(f\"Technical Skills Score for Candidate {candidate.first_name} {candidate.last_name}: {technical_score}\")\r\n\r\n        job_matching_score = float(calculate_job_matching_score(candidate, job_description, db))\r\n        print(f\"Job Matching Score for Candidate {candidate.first_name} {candidate.last_name}: {job_matching_score}\")\r\n    except Exception as e:\r\n        print(f\"Error during score calculation for candidate {candidate.first_name} {candidate.last_name}: {e}\")\r\n        return 0.0\r\n\r\n    # Ellenőrizzük, hogy bármelyik pontszám nullával tért-e vissza\r\n    if industry_score == 0 and technical_score == 0 and job_matching_score == 0:\r\n        print(f\"All scores are zero for candidate {candidate.first_name} {candidate.last_name}. Skipping...\")\r\n        return 0.0\r\n\r\n    final_score = float(\r\n        (industry_score * INDUSTRY_KNOWLEDGE_WEIGHT) +\r\n        (technical_score * TECHNICAL_SKILLS_WEIGHT) +\r\n        (job_matching_score * JOB_MATCHING_WEIGHT)\r\n    )\r\n\r\n    print(f\"Final Score for Candidate {candidate.first_name} {candidate.last_name}: {final_score}\")\r\n\r\n    # Adatbázis mentésének eltávolítása, csak visszatérünk a számított pontszámmal\r\n    return final_score\r\n# Jelöltek rangsorolása egy adott állásra\r\ndef rank_candidates_for_job(job_description: JobDescription, db: Session, top_n: int = 5) -> List[Dict]:\r\n    candidates = db.query(Candidate).all()\r\n    scores = []\r\n\r\n    print(f\"\\n=== Ranking Candidates for Job: {job_description.job_title} ===\")\r\n\r\n    def get_score_for_candidate(candidate):\r\n        # Minden szálnak új adatbázis kapcsolatot hozunk létre\r\n        with SessionLocal() as thread_db:\r\n            existing_score = thread_db.query(CandidateJobScore).filter_by(candidate_id=candidate.id,\r\n                                                                          job_id=job_description.id).first()\r\n            if existing_score:\r\n                score = existing_score.final_score\r\n            else:\r\n                score = calculate_and_save_final_score(candidate, job_description, thread_db)\r\n            return {\r\n                \"candidate\": candidate,\r\n                \"score\": score\r\n            }\r\n\r\n    with ThreadPoolExecutor(max_workers=20) as executor:\r\n        results = list(executor.map(get_score_for_candidate, candidates))\r\n\r\n    ranked_candidates = sorted(results, key=lambda x: x[\"score\"], reverse=True)[:top_n]\r\n\r\n    return [\r\n        {\r\n            \"candidate_id\": candidate[\"candidate\"].id,\r\n            \"first_name\": candidate[\"candidate\"].first_name,\r\n            \"last_name\": candidate[\"candidate\"].last_name,\r\n            \"score\": candidate[\"score\"]\r\n        }\r\n        for candidate in ranked_candidates\r\n    ]\r\n\r\n\r\n# Fő folyamat indítása\r\nif __name__ == \"__main__\":\r\n    preprocess_and_cache()  # Ne adj át db-t, mivel a függvény nem vár paramétert\r\n\r\n    while True:\r\n        db = SessionLocal()\r\n\r\n        try:\r\n            # Felhasználótól kérünk egy állásazonosítót\r\n            job_id = input(\"Add meg az állás azonosítóját (vagy 'exit' a kilépéshez): \")\r\n\r\n            # Kilépési feltétel\r\n            if job_id.lower() == 'exit':\r\n                break\r\n\r\n            try:\r\n                job_id = int(job_id)\r\n            except ValueError:\r\n                print(\"Érvénytelen állásazonosító. Próbáld újra.\")\r\n                continue\r\n\r\n            # Keresünk egy állást a megadott azonosítóval\r\n            job_description = db.query(JobDescription).filter_by(id=job_id).first()\r\n\r\n            if job_description:\r\n                print(f\"\\nÁllás leírás: {job_description}\")\r\n                ranked_candidates = rank_candidates_for_job(job_description, db)\r\n\r\n                print(\"\\n--- Rangsort Jelöltek ---\\n\")\r\n                for candidate in ranked_candidates:\r\n                    print(candidate)\r\n            else:\r\n                print(f\"Nincs találat az {job_id} azonosítójú álláshoz.\")\r\n\r\n        finally:\r\n            db.close()
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/core/matching.py b/core/matching.py
--- a/core/matching.py	(revision 67032de95fc7bc3746a36b11a2118994bd570f14)
+++ b/core/matching.py	(date 1729972444547)
@@ -206,7 +206,6 @@
 
 # Fő folyamat indítása
 if __name__ == "__main__":
-    preprocess_and_cache()  # Ne adj át db-t, mivel a függvény nem vár paramétert
 
     while True:
         db = SessionLocal()
